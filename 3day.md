# 개발자의 명언 : 착한 사용자는 없다.
  - 프로그램 할 때는 조건에 맞게 입력하겠지라고 생각을 하지 말자. 이런 것을 감안해서 프로그램을 해야 한다.
  
* printf 함수는 서식 지정이 가능하다. 
  - printf의 f은 "formatted"를 의미한다.
  - 서식 지정 : 출력의 형태를 지정한다는 의미 (ex; 문자열 안에 숫자 삽입)
  - 서식 지정의 예
  <pre>
  <code>
  #include <stdio.h>
  //#include <stadafx.h>
  
  int main(void)
  {
      int age = 12;
      printf("10진수로 %d살이고 16진수로 %x살 입니다.", age, age);
      return 0;
  
  }
  </code>
  </pre>

# 2. 변수와 연산자
## 3장. 변수와 연산자
* 연산자란 무엇인가? : 연산을 요구할 때 사용되는 기호
  - +, -, *, /
  
* 변수란 무엇인가? : 데이터를 저장할 수 있는 메모리 공간에 붙여진 이름. 영어 숫자로 표현하는데, 보통 영어로 표현한다.
  - 이유 : 컴퓨터는 영어권에서 만들어짐 -> 문자 체계를 영어권 기준으로 맞추어 놓음 -> 128개(남는 부분은 특수 문자를 할당하였다. -> 이를 ASCII라고 부른다.)
    - ASCII 코드 : 10진수 기준, 0 ~ 31 사이는 특수 문자로 구성되어 있다.(비어 있다). 통신과 관련된 문자로, 영어를 제외하고 다른 언어는 나타나지 않는다.
      - 0 : null(문자열 끝), LF : 10, CR  13
      - 2byte 코드 체계라는 기술을 도입 : 영문자 외의 문자들을 처리할 수 있는 기술 => Unicode => 코드 페이지에 의해 전 세계의 모든 문자들을 수용할 수 있다.

      - ASCII와 Unicode는 라이브러리와 운영체제에 탑재되어 있지만, 프로그래머라면 ASCII와 Unicode를 이해할 필요가 있다. (C# encoding, DB, etc)
  - 명언 : 착한 사용자는 없다. -> 사람은 모두 나쁘다라고 생각(ex, 3글자 입력하세요. 4글자를 입력하지 마세요 안내 -> 4글자 이상 적는 사람이 있음)
      
* 다양한 형태(자료형)의 변수
  - 정수형 : char(1), int(4), long(4, 8이 아님)
    * char : 배열 => 문자의 집합 -> 포인터
    * int, long 차이 : 역사적으론(DOS시절, int는 2byte, long은 4byte라고 설정. -> 컴퓨터 발전 속도가 올라가면서 int가 2byte에서 4byte로 변경되었다. 
    * 그러면 long은 8byte를 해야 하는거 아닌가? 레지스터 크기에 맞추자고 해서 long을 4byte라고 지정을 했다.
  - 실수형 : float(4), double(8)
    * double : 유효 자릿수, 지수부의 표현 능력이 훨씬 더 커지게 된다. 왠만한 실수 계산은 double을 사용한다고 생각하면 된다.
      * double을 사용할 때는 %f를 사용하면 된다.
    * **float를 사용한다면 신경을 많이 써줘야 한다.(double 보다 주의가 더 필요)**

  * 컴퓨터, 스마트폰 : APU(CPU 내장) + 보조메모리(address, data) 
  * 보조 메모리에 많은 address와 data에 OS(S/W)가 들어간다. (HDD/SSD)
  * age 변수라는 이름을 주소를 참조하기 위해, 컴파일러가 어디어디 address를 써서 데이터를 할당을 한다. (마치 아파트 분양 또는 신병 전입 시에 인사담당관이 보직 배치해주는 것과 같다.)
  
    - "a1b2c3" : 6개 글자, 끝에 0이 포함 -> 7byte 
    - "123" : 3개 글자 + 0 -> 4byte
    - 한글 3글자 byte 수 : 3 * 2 + 1(null) = 7bytes 
    - 참고 : 숫자 10개, 소문자 26개, 대문자 26개, 특수 기호 약 20개 가정 -> 약 82개 이상
  
* 변수의 선언 및 대입
  - 대입 연산자 (=) : 값을 대입하기 위한 용도의 연산자
  <pre>
  <code> 
  int main(void)
  {
      int val;    // int형 변수 val의 선언
      val = 20;   // 변수 val에 20을 저장
  }
  </code>
  </pre>
  
  <pre> 
  <code>
  // 예시 1
  #include <stdio.h>
  
  int main(void)
  {
      int a, b;   // 쓰레기 값으로 초기화
      int c = 30, d = 40;
      
      a = 10;
      b = 20;
      
      printf("%d %d \n", a, b);
      printf("%d %d \n", c, d);
      return 0;
  }
  </code>
  </pre>
  
  - 변수(함수) 선언 시 주의 사항 1 : 변수를 함수 내에 선언할 경우, 등장 위치
      * **변수(함수)는 사용되기 전에 미리 선언되어야 한다!**
  <pre> 
  <code>
  #include <stdio.h>
  
  int main(void)
  {
      int a;  // 변수(함수)는 사용되기 전에 선언되어야 한다. (필수!)
      int b;
      
      a = 10;
      b = 20; // 이런 방식은 컴파일러가 싫어합니다. 싫어하는 짓을 하면 컴파일러가 실행파일을 만들어주지 않는다.
      
      printf("%d %d \n", a, b);
      return 0;
  }
  </code>
  </pre>
  
  - 변수(함수) 선언 시 주의 사항 2 : 작명 (프로그래밍할 때 알고리즘보다 이름 구성때문에 시간이 오래 걸린다.)
    1. 변수의 이름은 알파벳, 숫자 언더바(_)로 구성
    2. 대소문자 구분
    3. 변수의 이름은 숫자로 시작 불가, 키워드 사용 불가
    4. 공백이 포함될 수 없음
    
    | 적절치 않은 변수의 이름 | 적절치 않은 이유 |
    |:----------:|:----------:|
    | int 7th_val | 변수의 이름이 숫자로 시작 |
    | int live_inthe# | #과 같은 특수 문자는 올 수 없다. |
    | int kor year | 변수 이름에 공백이 삽입될 수 없다. |
    
<pre>
<code>
// 덧셈 프로그램
/* simpleadd2.c */
#include <stdio.h>

int main(void)
{
    int result;   // 변수 선언
    result = 3 + 4; // 덧셈 결과
    
    printf("덧셈 결과: %d \n", result);
    printf("%d 더하기 %d는 %d입니다.\n", 3, 4, result);
    printf("변수 result에 저장된 값 : %d \n", result);
    
    return 0;
    
}
</code>

</pre>

* 변수와는 다른 상수!
  - 상수도 메모리 공간을 할당받는다. 하지만 데이터의 변경이 불가능하다.
    - 변수
    <pre>
    <code>
    #include <stdio.h>
    
    int main(void)
    {
        int a = 20;
        a = 30;
        printf(a);
    }
    
    // 결과 : 30 (변수 : 변경 가능)
    </code>
    </pre>
    
    - 상수 : 프로그램 소스에 삽입되어 있는 모든 숫자 문자열은 모두 상수
    <pre>
    <code>
    #include <stdio.h>
    
    int main(void)
    {
        const int b = 20; // const : constants (상수)
        b = 30;
        printf(b);
    }
    
    // 결과 : 오류 
    </code>
    </pre>
    
* 대입 연산자와 산술 연산자
    | 연산자 | 연산의 예 | 의미 | 결합성 |
    |:------:|:---------:|:-------:|:-------:|
    | = | a = 20 | 대입 | <- |
    | + | a = 4+3 | 덧셈 | -> |
    | - | a = 4-3 | 뺄셈 | -> |
    | * | a = 4*3 | 곱셈 | -> |
    | / | a = 4/3 | 나눗셈 | -> |
    | % | a = 4%3 | 나머지 | -> |
    
* 기타 대입 연산자
  - a = a+b;    <=>   a +=b;
  - a = a-b;    <=>   a -=b;
  - a = a*b;    <=>   a *=b;
  - a = a/b;    <=>   a /=b;
  - a = a%b;    <=>   a %=b;
  
* 부호 연산으로서 +, - 연산자
* 증가 감소 연산자(포맷 문자열이 필요함! ex) "%d")

    | 연산자 | 연산의 예 | 의미 | 결합성|
    |:------:|:---------:|:-------:|:-------:|
    | ++a | print("%d", ++a) | 선 증가, 후 연산 | <- |
    | a++ | print("%d", a++) | 선 연산, 후 증가 | <- |
    | --a | print("%d", --a) | 선 감소, 후 연산 | <- |
    | a-- | print("%d", a--) | 선 연산, 후 감소 | <- |
    
      - a = 3 -> 출력값은?
      - print("%d", ++a) : 4, print("%d", a++) : 3(후에 a = 4)
      - print("%d", --a) : 2, print("%d", a--) : 3(후에 a = 2)

* 관계 연산자(비교, 논리 연산자)
  - 두 피연산자의 관계(크다, 작다, 같다)를 따지는 연산자
  - true(논리적 참, 1), false(논리적 거짓, 0) 반환
  - 관계 연산자에서 왼쪽에 있는 변수가 기준이다.
  - 조건문에서 매우 빈번하게, 대부분 사용하는 연산자이다.
  
    | 연산자 | 연산의 예 | 의미 | 결합성 |
    |:------:|:---------:|:-------:|:-------:|
    | <(GT) | a < b | a가 b보다 작은가 | -> |
    | >(LT) | a > b | a가 b보다 큰가 | -> |
    | ==(E) | a == b | a와 b가 같은가 | -> |
    | !=(NE) | a != b | a와 b가 같지 않은가 | -> |
    | <=(GE) | a <= b | a가 b보다 작거나 같은가 | -> |
    | >=(LE) | a >= b | a가 b보다 크거나 같은가 | -> |
    
      - GT : Greater Than / LT : Less than
      - LE : Less Equal / GE : Greater Equal
      - E : Equal / NE : Not Equal

* 논리 연산자 
  - and, or, not(이들을 논리값이라고 한다.)을 표현하는 연산자
  - true(1), false(0) 반환
  - 조건문에 많이 사용된다. 하지만 조건문에 사용할 때 중첩하여 사용한다면, 괄호를 적극적으로 사용해야 한다.
    *      연산자            연산의 예        의미                           결합성
    *      &&(and, 논리곱)     a&&b      true면 true 리턴                     ->
    *      || (or, 논리합)     ||        하나라도 true면 true 리턴            ->
    *      !(not)              !a        true면 false를, false면 true리턴     ->
    
    - | : vertical bar
    
* 비트 연산자(정리하기)
  * -, ~, &, ^, |, <<, >>
  
* 콤마(,) 연산자
  - 둘 이상의 변수 동시 선언 시
  - 둘 이상의 문장을 한 줄에 선언 시
  - 함수의 매개변수 전달 시
  - 익숙한 사람은 단순하게 작성할 수 있는 효과가 있지만, 가독성이 낮아지는 효과가 있다.
  
* 세미콜론(;) = C언어에서 무조건 사용! -> 콤마도 이러한 기능과 조금 비슷한 역할을 
  
* 연산자의 우선 순위 (정리)
  - 연산 순서를 결정짖는 순위
  [ { ( ) } ] -> only ( )만!
* 연산자의 결합성
  - 우선 순위가 같은 연산자들의 연산 방향
    - ex) 3+4*5/2-10 =3 

* C 언어의 키워드들 (이텔릭체 : 사용 X, 진한 글씨 : 데이터 타입, 보조 역할, 괄호 표시 : 변수의 위치 표시)
  
  | 목록1 |  목록2 |  목록3 |  목록4 |
  |:----:|:-----:|:-----:|:----:|
  | auto | **double** | **int** | struct |
  |**bool** | else | **long** | switch |
  | break | enum | *register* | typedef |
  | case | (extern) | *restrict* | union |
  | **char** | **float** | return | **unsigned** |
  | **const** | for | **short** | **void** |
  | continue | goto | **signed** | *volatile* |
  | default | if | sizeof | while |
  | do | inline | (static) | |
  
  - bool : 논리 변수 type (true, false), C에서는 사실상 int와 동격으로, 구별없이 쓴다.
    * 다만, 다른 언어에서는 혼용이 안되는 경우가 많으니까, int와 bool를 구별하여 쓰자.
    * short, long 나눈 이유 : int가 2byte, long이 4byte인 시절이 있었는데, 고성능 프로세서 개발으로 int, long가 4byte로 처리가 되어졌는데, 
    int가 4byte로 변경 전에 int가 2byte로 사용했을 때의 경우에 문제가 발생하였다. 따라서 이전의 2byte를 차지했던 int를 short int 즉, short로 지정하게 되었다.
    * 따라서 short는 2byte int라고 생각하면 된다.
    * short를 사용하는 이유 : 문자 (2byte 문자체계의 문자) -> unicode
  
  - signed / unsigned : signed을 사용하지 않으면 unsigned이기 때문에, unsigned(양수)를 잘 사용하지 않는다.
    - 사용법 (int, long, short, char 에 사용)
  
  - unsigned short : 2byte = 16bit : 0 ~ 65535 표현 가능 
  - signed short : 2byte = 16bit : -32768 ~ 32767 표현 가능 
  
  - const : 상수(constants), 한번 선언하면 절대 변경되지 않는다.
  
  - inline : C++/Assembly에서 쓴다. 일반적인 경우에서 사용을 잘 하지 않는다.
  - void
    * 미확정 타입
    * 함수의 타입을 결정할 때 사용
    * 단독 데이터 타입이 아니다. 많이 쓰이는 곳은 포인터 연산과 선언이다. 포인터 연산과 밀접한 관계가 있기 때문
    
  - sizeof (키워드는 아니다. 매크로이다.)
   * 참고 : 솔루션 탐색기 -> 프로젝트 새로 만들기 -> 새로 프로젝트 생성
   
## 4장. 데이터 표현 방식의 이해
* 진법에 대한 이해
  - n 진수 표현 방식 : n개의 문자를 이용해서 데이터를 표현
    - 2진수 표현 범위 : 0 1
    - 10진수 표현 범위 : 0 1 2 3 4 5 6 7 8 9
    - 16진수 표현 범위 : 0 1 2 3 4 5 6 7 8 9 a b c d e f (참고: 16진수는 부호가 없다.)
      - 16_(10) = 10_(16) (16^1 + 0 * 16^0)
    * 참고 : 프로그래밍 할 때, 이진수 생각한다고 해서 2씩 나누는 짓 하지 마라. 컴퓨터로 다 되는 것
    
* 데이터의 표현 단위인 비트(bit)와 바이트(byte)
  - 비트 : 데이터 표현의 최소 단위, 2진수 값 하나 (0 or 1)을 저장
  - 바이트 : 8비트 (= 1바이트)
    - 0 1 1 0 1 1 0 1 / 0 1 0 1 1 0 1 0 (1개당 1비트)
    
  - 예시
    * 0 0 0 0 0 0 0 0 : 0
    * 0 0 0 0 0 0 0 1 : 1   = 2^0
    * 0 0 0 0 0 0 1 0 : 2   = 2^1 
    * 0 0 0 0 0 1 0 0 : 4   = 2^2
    * 0 0 0 0 1 0 0 0 : 8   = 2^3
    * 0 0 0 1 0 0 0 0 : 16  = 2^4
    * 0 0 1 0 0 0 0 0 : 32  = 2^5
    * 0 1 0 0 0 0 0 0 : 64  = 2^6
    * 1 0 0 0 0 0 0 0 : 128 = 2^7
  
    * 2^8 = 256, 2^9 = 512, 2^10 = 1024 ≒ 1K(1000) = 10^3
  
* 프로그램상에서의 8진수, 16진수 표현
  - 8진수 : 0으로 시작
  - 16진수 : 0x로 시작(중요)
  <pre>
  <code>
  int a = 10; // 10진수, 아무런 표시가 없으므로..
  int b = 0xa; // 16진수, 0x로 시작하므로...
  int c = 012;  // 8진수, 0으로 시작하므로... (권장하지 않는다. 10진수와 헷갈리는 경우가 많다.)
  </code>
  </pre>
  
* 정수의 표현 방식
  - MSB : 가장 왼쪽 비트, 부호를 표현, 가장 최상위 비트
  - MSB를 제외한 나머지 비트 : 데이터의 크기 표현 
  - ![image](https://user-images.githubusercontent.com/49339278/128151406-4be9015e-fd4a-4224-8eb1-d104eefd72cd.png)

    - 첫 번째 bit : MSB, 그 외 bits : 데이터의 크기 표현
    - unsigned라는 키워드를 붙였을 시, MSB에 숫자표현방식이 들어갈 수 있다.
    
* 잘못된 음의 정수 표현 방식
  - 양의 정수 표현 방식을 적용한 경우
    - ![image](https://user-images.githubusercontent.com/49339278/128151218-138b082c-5741-457d-9fd0-c082d1eb7fc6.png)

    - (결과) 1 0 0 0 1 0 1 0 (오류 발생. 0이 아니다.)
    
* 정확한 음의 정수 표현 방식
  - 2의 보수를 이용한 음의 정수 표현 방식
    - ![image](https://user-images.githubusercontent.com/49339278/128151266-3b42c4ec-5b35-4b42-adc9-2e2eaf66e97c.png)

  - 증명
    - ![image](https://user-images.githubusercontent.com/49339278/128151324-494c4d98-e938-49e5-8f6c-e3091b2e6c94.png)

* 잘못된 실수의 표현 방식
  * 정수를 표현하는 방식을 실수 표현에 적용
  * 작은 수를 표현하는 데 있어서 한계를 지님
  - ![image](https://user-images.githubusercontent.com/49339278/128151562-a52894bf-b617-411a-9908-8511de4e48ed.png)

* 정확한 실수 표현 방식
  - 단점 : 오차가 존재
  - 장점 : 효율적인 표현 방식
  - ![image](https://user-images.githubusercontent.com/49339278/128151736-4f9c4e59-9a88-4b68-8bab-9f675fffdc5f.png)

  
* 비트 연산 : 컴퓨터의 내부 데이터 표현 방식인 비트(bit) 단위의 연산(&, |, !)
  * 논리 기호 : 논리 대수에 의한 연산을 하기 위한 연산자나 기능을 나타내는 기호로, 논리 회로를 도시하기 위해 사용한다.
    - ![image](https://user-images.githubusercontent.com/49339278/128151775-4c18bddb-781d-4604-8d33-e3e836921157.png)


  - 비트 단위 연산자의 종류(>>와 <<는 C에서만 사용한다. C++는 함부로 쓰다가 이상한 결과가 나온다. 따라서 꼭 필요한 경우가 아니면 사용하지 않는다.)
  
    *       연산자    연산의 의미                      예시     결합성
    *         &       비트 단위 AND                 ex) a & b     □
    *         |       비트 단위 OR                  ex) a | b     □
    *         ^       비트 단위 XOR (배타적 논리합) ex) a ^ b     □
    *         ~       비트 단위 NOT                 ex) ~a        □
    *         <<      왼쪽으로 이동(SHL), *2 효과   ex) a << 2    □
    *         >>      오른쪽으로 이동(SHR) /2 효과  ex) a >> 2    □
    
    * ^연산자는 보통 암호처리할 때 사용하기도 한다.
    - A   : 0 1 0 1
    - B   : 0 0 1 1
    - A&B : 0 0 0 1
    - A|B : 0 1 1 1
    - A^B : 0 1 1 0 (비교되는 두 개의 값 비트가 같으면 0, 달라야만 1)
    - ~A  : 1 0 1 0
    - A<<2: 1 0 1 0 1
    - A>>2 :0 0 1 0
    
    * 추가 >>, << 설명 (통신 프로토콜 사용할 때 비트를 검사하기 위해 가끔 사용하는 경우가 더러 있음.)
      - a = 0000000000001111
      - a>>2 = 0000000000111100 (*2 효과)
      - a<<2 = 0000000000000011 (/2 효과)
    
## 5강. 상수와 기본 자료형
* C언어의 기본 자료형
  - 자료형(data type) : 선언한 변수의 특징을 나타내기 위한 키워드
    - 기본 자료형 : 기본적으로 제공이 되는 자료형
    - 사용자 정의 자료형 : 구조체, 공용체
    
  - 기본 자료형의 종류와 데이터의 표현 범위
    - ![image](https://user-images.githubusercontent.com/49339278/128269579-8e9dd5e9-7c96-4e7b-bd86-cb9f62796222.png)
    
  - 다양한 자료형이 제공되는 이유
    - 데이터의 표현 방식이 다르기 때문 : 정수형 / 실수형 데이터를 표현하는 방식
    
  - 메모리 공간을 적절히 사용하기 위해서
    - 데이터의 표현 범위를 고려해서 자료형 선택
    - 작은 메모리 공간에 큰 데이터를 저장하는 경우, 데이터의 손실이 발생할 수 있음
    
- sizeof 연산자
  - 피연산자의 메모리 크기를 반환
  - 피연산자로 자료형의 이름이 올 경우 괄호를 사용
  - 그 이외의 경우 괄호의 사용은 선택적
    
    <pre>
    <code>
    int main(void)
    {
        int val = 10;
        printf("%d", sizeof val); // 변수 val의 메모리 크기 출력
        printf("%d", sizeof(int));  // 자료형 int의 메모리 크기 출력
    }
    </code>
    </pre>
       

* 자료형 선택의 기준
  - 정수형 데이터를 처리하는 경우
    - 컴퓨터는 내부적으로 int형 연산을 가장 빠르게 처리한다. 따라서 정수형 변수는 int 형으로 선언
    - 범위가 int형 변수를 넘어가는 경우 long 형으로 선언
    - 값의 범위가 -128 ~ + 127사이라 할지라도 int형으로 선언
    
  - 실수형 데이터를 처리하는 경우
    - 선택의 지표는 정밀도, 정밀도란 오차 없이 표현 가능한 정도 의미
      - 선택의 지표는 정밀도로, 오차 없이 표현 가능한 정도를 의미한다.
      - 일반적 선택은 double
      - ![image](https://user-images.githubusercontent.com/49339278/128269842-8716b182-4bc5-410b-a8f5-4585cc8f6589.png)

- unsigned가 붙어서 달라지는 표현의 범위
  - MSB까지도 데이터의 크기를 표현하는데 사용
  - 양의 정수로 인식
  - 실수형 자료형에는 붙일 수 없다.
    - ![image](https://user-images.githubusercontent.com/49339278/128269896-36db7359-b75a-401f-836e-68901a98cd33.png)

- 문자 표현을 위한 ASCII 코드의 등장
  - 미국 표준 협회(ANSI)에 의해 정의
  - 컴퓨터를 통해서 문자를 표현하기 위한 표준이다. 컴퓨터는 그 자체적으로 문자를 표현하지 못하기 때문
  - 문자와 숫자의 연결 관계를 정의
    - 문자 A는 숫자 65, 문자 B는 숫자 66...
    
- ASCII 코드의 범위
  - 0이상 127이하, char형 변수로 처리 가능
  - char형으로 처리하는 것이 합리적
  
- 문자의 표현 : 따옴표('')를 이용해서 표현
  - char ch1 = 'A'

- 리터럴(Literal) 상수 : 이름을 지니지 않는 상수
  <pre>
  <code>
  int main(void)
  {
      int val = 30 + 40;  // val : 변수, 30, 40 : 리터럴 상수(이름 없음)
  }
  </code>
  </pre>

- 리터럴(Literal) 상수의 기본 자료형 : 상수도 메모리 공간에 저장되기 위해서 자료형이 결정된다.
  <pre>
  <code>
  int main(void)
  {
      char c = 'A'; // 문자 상수(char)
      int i = 5;    // 정수 상수(int)
      double d = 3.15// 실수 상수(double)
  }
  </code>
  </pre>
  
  - 리터럴 상수의 기본 자료형
  <pre>
  <code>
  int main(void)
  {
      float f = 3.14 ; // float f = 3.14f
      return 0;
  }
  </code>
  </pre>
  
    - warning C4305: 'initializing' : truncation from 'const double' to 'float'
  
- 접미사에 따른 다양한 상수의 표현
  - ![image](https://user-images.githubusercontent.com/49339278/128270405-c67e5e10-5bdc-49fc-9f83-5b8ef3c25510.png)

- 심볼릭(symbolic) 상수 : 이름을 지니는 상수
- 심볼릭 상수를 정의하는 방법
  - const 키워드를 통한 변수의 상수화
  - 매크로를 이용한 상수의 정의
  
- const 키워드에 의한 상수화
<pre>
<code>
int main(void)
{
    const int MAX = 100;
    const double PI = 3.1415;
}
</code>
</pre>

  - 잘못된 상수 선언
  <pre>
  <code>
  int main(void)
  {
    const int MAX;
    MAX = 100;
  }
  </code>
  </pre>
  
- 자료형 변환의 두 가지 형태
  1. 자동 형 변환(= 묵시적 형 변환)
    - 자동적으로 발생하는 형태의 변환
    - 오류 발생 소지가 높다.
    
    - 자동 형 변환이 발생하는 상황 
      1. 대입 연산시
        <pre>
        <code>
        int main(void)
        {
          int n = 5.25; // 소수부의 손실
          double d = 3; // 값의 표현이 넓은 범위로의 변환
          char c = 129; // 상위 비트의 손실
        </code>
        </pre>
        
      2. 정수의 승격에 의해 (int형 연산이 빠른 이유)
        - 정수형 연산 자체를 단일화시킨 결과
        <pre>
        <code>
        int main(void)
        {
          char c1 = 10, c2 = 20;
          char c3 = c1 + c2 ;
        </code>
        </pre>
        
      3. 산술 연산 과정에 의해
        <pre>
        <code>
        int main(void)
        {
          double e1 = 5.5 + 7;      // double + int
          double e2 = 3.14f + 5.25; // float + double
        
        </code>
        </pre>
        
      * 산술 연산 형 변환 규칙 : 데이터의 손실이 최소화되는 방향으로
        - char -> int -> long -> float -> double -> long double
        - 역으로도 가능하지만, 데이터의 손실이 생기기 때문에 일부로 의도적으로 하지 않는 이상 하지 않는 것이 좋다.
        
  2. 강제 형 변환(= 명시적 형 변환, cast라고 한다.)
    - 프로그래머가 명시적으로 형 변환을 요청하는 형태의 변환
    - Cast 연산자
    <pre>
    <code>
    float f = (float)3.14;    // 3.14를 float형으로 형 변환
    double e1 = 3 + 3.14;     // 정수 3이 double 형으로 자동 형 변환
    double e2 = 3 + (int)3.14;  // 3.14가 int
    </code>
    </pre>
    
