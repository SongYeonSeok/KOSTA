# 7강. C 표준함수
* 호환성이 높아서 임의의 플랫폼에서도 사용이 가능하다.
  * 그 이유는 OS마다 제공하는 컴파일러가 다르기 때문에, 호환성 여부를 확인해 보아야 한다. 
  * C언어는 이식성이 굉장히 높아서, 따로 손을 쓰지 않아도 사용 기능하다.

## 24. 문자와 문자열 처리 함수

* 입출력의 이해
  * 파일, 콘솔, 소켓 입출력
    * 파일이 입력과 출력의 원형이다.
    * 콘솔은 특수 파일이라고 이해하면 된다. 실제로 특수 파일이다.
* 스트림에 대한 이해
  * 데이터를 송수신 하기 위한 일종의 다리 (데이터의 흐름이라고 생각하면 편하다)
  * ![image](https://user-images.githubusercontent.com/49339278/129317904-f42b2fbd-adbb-47ca-a430-8b59fff90b48.png)

* 표준 입출력 스트림 = File의 개념
  * 프로그램 실행 시 자동으로 생성 및 소멸
  * 모니터와 키보드를 그 대상으로 함
  
  | 이름 | 스트림의 종류 | 입출력 장치 |
  |:----:|:----:|:----:|
  | stdin | 표준 입력 스트림 | 키보드 |
  | stdout | 표준 출력 스트림 | 모니터 |
  | stderr | 표준 에러 스트림 | 모니터 |

* 문자 출력 함수
```c
#include <stdio.h>

int putchar(int c);
int fpuct(int c, FILE* stream);     // fprintf (앞의 f = file) 사용하면 된다.
// 에러가 발생하는 경우 EOF 리턴
```

* 문자 입력 함수
```c
#include <stdio.h>

int getchar(void)
int fgetc(FILE* stream);            // fscanf (앞의 f = file) 사용하면 된다.
// 에러가 발생하거나 파일의 끝에 도달하는 경우 EOF 리턴
```

* EOF에 대한 이해
  * file을 읽을 때, 끝에 도달했다는 read 함수의 **return 값**이다.
  * fgetc, getchar 함수가 파일의 끝에 도달하는 경우 반환
  * End-Of-File의 약자로서, 파일의 끝을 표현하기 위한 상수
  (-1의 값을 지닌다.)
    * 꼭 그렇지는 않다.
  * 콘솔의 경우 Ctrl-Z가 파일의 EOF를 의미
    * 그 의미는 

* 문자 단위 입출력 함수의 필요성
  * 용도에 맞는 적절한 함수를 제공함으로써 성능 향상을 도모

```c
// char_IO.c
#include <stdio.h>

int main()
{
  char ch = 0;
  
  while(ch != 'q')
  {
    ch = getchar();
    putchar(ch);
  }
  
  return 0;
}
```

```c
// Ctrl_Z.c
#include <stdio.h>

int main()
{
  char ch = 0;
  
  while(ch != EOF)
  {
    ch = getchar();
    putchar(ch);
  }
  printf("program 종료 \n");
  
  return 0;

```

* 문자열 출력 함수
```c
#include <stdio.h>

int puts (const char* s);
int fputs(const char* s, FILE* stream);  // FILE : 새로운 data type
```

* 문자열 입력 함수
```c
#include <stdio.h>

char* gets(char* s);
char* fgets(char* s, int n, FILE* stream);
```

```c
// puts_fputs.c
#include <stdio.h>

int main()
{
  fputs("fputs 함수에 의한 출력, ", stdout);
  fputs("I Love Linux ", stdout);
  
  fputs("\n", stdout);  // 한 줄 건너뛰기 위해서
  puts("puts 함수에 의한 출력,");
  puts("I Love Linux ");
  
  return 0;
}

```

```c
// fputs.c
#include <stdio.h>

int main()
{
  char str[10];
  
  fputs("문자열을 입력 하세요 : ", stdout);
  fgets(str, sizeof(str), stdin);
  
  fputs("입력된 문자열 : ", stdout);
  fputs(str, stdout);
  
  return 0;
}

```

* cmd -> echo "내용" > "파일이름" -> 파일 생성
* cmd -> dir : 디렉토리 확인
* cmd -> dir 파일명* : 디렉토리에서 '파일명' 글자가 있는 모든 파일을 보여준다.
* cmd -> type 파일명 : 내용물 출력

* 입출력 사이에 존재하는 버퍼의 이해
  * 여분의 임시 메모리적 특징을 지닌다.
  * 성능 향상이 목적이다.
  * 모아서 보내고... 모아서 받고...
![image](https://user-images.githubusercontent.com/49339278/129839871-922b7c63-e343-4e89-9f8c-fc37ccbf085e.png)

* 버퍼를 비우는 작업을 하는 fflush 함수
```c
#include <stdio.h>

int fflush(FILE * stream);

// 성공 시 0, 실패 시 EOR 리턴
```![image](https://user-images.githubusercontent.com/49339278/129839964-0c566312-751f-4a48-a659-6af7a5ce0423.png)

```c
// fflush.c
#include <stdio.h>

int main(void)
{
  char perID[7];  // 6 + null 문자 = 7
  char name[10];
  
  fputs("주민번호 앞 6자리 입력하세요 : ", stdout);
  fgets(perID, sizeof(perID), stdin);
  
  fflush(stdin); // 입력 버퍼를 비운다.
  
  fpust("이름을 입력하세요 : ", stdout);
  fgets(name, sizeof(name), stdin);
  
  printf("주민번호 앞자리 : %s\n", perID);
  printf("이           름 : %s\n", name);
  
  return 0;
}
```

* 문자열의 길이를 반환하는 strlen 함수
  ```c
  #include <stdio.h>
  
  size_t strlen(const char* s)
  // 성공 시 0, 실패 시 EOF 리턴
  ```

* 문자열을 복사하는 함수
  ```c
  #include <string.h>
  
  char* strcpy(char* dest, const char* src);
  char* strncpy(char* dest, const char* stc, size_t n);
  // 리턴 시 복사된 문자열의 포인터 리턴
  ```
* 복사 참조
```c
// strlen.c
#include <stdio.h>
#include <string.h>

int main(void)
{
  char str[100];
  
  while(1)
  {
    fgets(str, sizeof(str), stdin);
    printf("문자열의 길이 : %d \n", strlen(str));
  }
  
  return 0;
}

```

* 문자열을 추가하는 함수
```c
#include <string.h>

char* strcat(char* dest, const char* src);
char* strncat(char* dest, const char* src, size_t n);
// 리턴 시 추가된 문자열의 포인터 리턴
```
![image](https://user-images.githubusercontent.com/49339278/129840457-53c64b7f-1e43-40f5-a22e-429ff69c3187.png)

```c
// strcat.c
#include <stdio.h>
#include <string.h>

int main(void)
{
  char str1[30] = "Your favorite language is "; // null 문자 포함 27문자
  char str2[10];
  
  fputs("What is your favorite computer language ? : ", stdout);
  fgets(str2, sizeof(str2), stdin);
  
  strcat(str1, str2);
  printf("생성된 문자열 : %s \n", str1);
  return 0;
}
```
* 문자열을 비교하는 함수
```c
#include <string.h>
int strcmp(const char* s1, const char* s2);
int strncmp(const char* s1, const char* s2, size_t n);
// 리턴 시 추가된 문자열의 포인터 리턴
```

| 리턴 값 | 의미 |
|:-----:|:----|
| 0보다 큰 값(양수) | str1이 str2 보다 큰 경우 |
| 0 | str1과 str2가 완전히 같은 경우 |
| 0보다 작은 값(음수) | str1이 str2 보다 작은 경우 |

```c
// strcamp.c
#include <stdio.h>
#include <string.h>

char* str1 = "ABC";
char* str2 = "ABD";

int main(void)
{
  int result;
  result = strcmp(str1, str2);
  
  if(result > 0)       puts("str1이 str2보다 큽니다.");
  else if (result <0)  puts("str2이 str1보다 큽니다.");
  else                 puts("두 문자열이 정확히 같습니다.");
  
  return 0;
}
```

* 문자열을 숫자로 변환하는 함수들
```c
#include <stdlib.h>

int atoi(char* ptr); // 문자형을 int형 데이터로 변환
long atoi(char* ptr); // 문자열을 long형 데이터로 변환
doubld atof(char* str);  // 문자열을 double형 데이터로 변환
```

* 대소문자의 변환을 처리하는 함수들
```c
#include <ctypes.h>

int toupper(int c);  // 소문자를 대문자로
int tolower(int c);  // 대문자를 소문자로
```

## 25. 파일 입, 출력
* 파일의 OPEN
  * 데이터를 주고 받을 수 잇는 스트림의 생성
  ```c
  #include <stdio.h>
  FILE* fopen(const char* filename, const char* mode)
  /*
  성공 시 해당 파일의 파일 포인터, 실패 시 NULL 포인터 리턴
  */
  ```

* 파일 OPEN mode
  * 파일 접근 모드 + 데이터 입출력 모드

* 파일 접근 모드
  * 개방한 파일의 사용 용도 확인
  * r, w, a, r+, w+, a+
    * r : read, w : write, a : append(추가 - 기존의 파일 없으면 새로 만들어 기록해 나감.)
    * r+ :  w+, a+ 는 텍스트 모드나 2진 모드와 같은 데이터 입출력 모드를 덧붙이기 위해서이다.
      * 하지만 a+t는 a와 같아서 의미가 없다.
 
  * 로그 파일 : 운영 체제나 다른 소프트웨어가 실행 중에 발생하는 이벤트나 각기 다른 사용자의 통신 소프트웨어 간의 메시지를 기록한 파일

* 데이터 입, 출력 모드

  | 모드 | 의미 |
  |:---:|:-----|
  | t | 텍스트 모드(text mode), CRLF |
  | b | 2진 모드(binary mode) |

* CR & LF : 개행문자, white space
  * CR은 특수문자 '\r'로 표시
  * LF는 특수문자 '\n'로 표시

![image](https://user-images.githubusercontent.com/49339278/129866858-178d02f7-6e88-4591-80bc-37cbd079338f.png)


* 텍스트 모드와 2진 모드의 차이점
![image](https://user-images.githubusercontent.com/49339278/129867047-b296b7ca-8dd1-483c-8867-8710a2dbf80b.png)


* 파일 개방 모드의 완성
![image](https://user-images.githubusercontent.com/49339278/129867107-876abd6d-07dc-43f4-b2fb-87b3a5edf8a6.png)


* FILE 구조체의 포인터
  * fopen 함수의 리턴 타입
  * 흔히 파일 포인터라고 불린다.
  * 개방한 파일에 대한 여러 가지 정보를 지니는 변수를 가리키는 포인터

* FILE 구조체 포인터의 용도
  * 데이터 입출력 함수의 호출
  * 위치 정보의 참조
  * 파일의 끝 확인
 
* 파일의 종결(CLOSE)
  * 스트림의 종결을 의미함.
  ```c
  #include <stdio.h>
  int fclose(FILE * stream)
  // 종료가 오류 없이 제대로 이뤄지면 0을 리턴
  ```
  
  | 기능 \ 스트림 | 키보드/모니터 | 선택(키보드/모니터, 파일) |
  |:-----:|:------|:------|
  | 문자 출력 | ```int putchar(int c)``` | ```int fputc(int c, FILE* stream)``` |
  | 문자 입력 | ```int getchar(void)``` | ```int fgetc(FILE* stream)``` |
  | 문자열 출력 | ```int puts(const char* s)``` | ```int fputs(const char* s, FILE* stream)``` |
  | 문자열 입력 | ```char* gets(char* s)``` | ```char* fgets(char* s, int n, FILE* stream)``` |
  | 형식 지정 출력 | ```int printf(const* format, ...)``` | ```int fprintf(FILE* stream, const char* format, ...)```|
  | 형식 지정 출력 | ```int scanf(const char* format, ...)```|```int fscanf(FILE* stream, const char* format, ...)```|
