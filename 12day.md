* C++ = C + OOP (C++에서 C 문법 사용 가능)
* Java = C - ```*```
* C# = C++ + .NET Framework(런타임 라이브러리)
* Java != JavaScript

# 1. C언어 기반의 C++ 1
## Chapter 1. printf와 scanf를 대신하는 입출력 방식

* C++ 버전의 Hello World 출력 프로그램
```c++
#include <iostream>

int main(void)
{
  int num = 20;
  std::cout << "Hello World!<< std:endl;    // :: : 클래스 멤버를 의미(C언어의 .과 같다.)
  std::cout << "Hello " << "World!" << std::endl;
  std::cout << num << ' ' <<'A';
  std::cout << ' ' <<3.14<<std:endl;
  return 0;
  
}
/* 실행 결과
Hello World!
Hello World!
20 A 3.14
*/
```

  - 꺽쇠 표시 << : C 언어의 shift 연산자로, <<는 ```*2```를 의미!
    - 그런데 C++에서는 redirection이라고 함. 즉, stream의 진행 방향을 의미한다.
  
  - 헤더 파일의 선언 : ```#include <iostream>```
  - 출력의 기본구성 : std::cout << '출력대상1'<<'출력대상2'<<'출력대상 3';
    - 1 -> 2 -> 3 순서대로 출력
    - std : namespace
  - 개행의 진행 : std::endl을 출력하면 개행이 이뤄진다.
  - **C 언어에서는 출력의 대상에 따라 서식 지정을 달리했지만, C++ 에서는 그러한 과정이 불필요하다. **
  - 참고 : 그냥 printf 사용해라 ㅎㅎㅎㅎ

* scanf를 대신하는 데이터의 입력
  * 입력의 기본 구성 : ```std::cin>>'변수'```
  * 변수의 선언 위치 : 함수의 중간 부분에서도 변수의 선언이 가능하다.
  ```c++
  #include <iostream>
  
  int main(void)
  {
    int val1;
    std::cout<<"첫 번째 숫자입력 : ";
    std::cin>>val1;       // 프롬프트, 
                          // 편리한 점 : C과 다르게, 입력하는 변환자 쓸 필요가 없다(때려 넣는게 가능)
    int val2;             // C++에서는 변수의 선언위치에 제한을 두지 않는다. (밑에 설명 참고)
                          // 그 이유는 reference를 사용하여 pointer 대신 사용하므로
    std::cout<<"두 번째 숫자입력 : ";
    std::cin>>val2;
    int result = val1+val2;   // C++에서는 변수의 선언위치에 제한을 두지 않는다.
    std::cout <<"덧셈 결과: "<<result<<std::endl;
    return 0;
  }
  /* 출력 결과
  첫 번째 숫자입력 : 3
  두 번째 숫자입력 : 5
  덧셈결과: 8
   
  */
  ```
  
  * 변수와 함수는 사용되기 전에 선언되어야 한다는 것이 C언어의 국룰이었다.
  * 그러나 C++에서는 변수의 선언위치에 제한을 두지 않는다. 
  하지만, 변수와 함수를 사용되기 전에 선언하는 것으로 습관을 들이자!
  * 출력에서와 마찬가지로 입력에서도 별도의 서식 지정이 불필요하다.

* C++의 지역변수 선언
```c++
#include <iostream>  // <iostream> : 헤더파일
int main(void)
{
  int val1, val2;
  int result = 0;
  std::cout<<"두 개의 숫자입력: ";
  std::cin>>val1>>val2;  // 이렇듯 연이은 데이터의 입력을 명령할 수 있다.
  if (val1 < val2)
  {
    for (int i=val1+1; i<val2;i++)
      result+=i;
  }
  else
  {
    for (int i=val2+1; i<val1;i++)  //for문 안에서도 변수의 선언이 가능하다.
  }
  std::cout<<"두 수 사이의 정수 합: "<<result<<std::endl;
  return 0;
}
/* 실행 결과
두 개의 숫자 입력 : 3 7
두 수 사이의 정수 합  15
*/
```

* std::cin을 통해서 입력되는 데이터(이어서 필기하기)

* 배열 기반의 문자열 입출력
  * 문자열의 입력 방식도 다른 데이터의 입력 방식과 큰 차이가 나지 않는다.

## Chapter1-2 함수 오버로딩(Function Overloading)
* 똑같은 함수명. 하지만 인자가 다르다.
* 함수 오버로딩의 이해
  * C++은 함수 호출 시 '함수의 이름'과 '전달되는 인자의 정보'를 동시에 참조하여 호출할 함수를 결정한다.
  따라서 이렇듯 매개변수의 선언이 *다르다면* 동일한 이름의 함수도 정의 가능하다. *이러한* 형태의 함수
  정의를 가리켜 **'함수 오버로딩**이라 한다.
  
* 함수 오버로딩의 예
  1. 매개변수의 자료형이 다르므로 함수 오버로딩 성립
  2. 매개변수의 수가 다르므로 함수 오버로딩 성립
  3. 반환형의 차이는 함수 오버로딩의 조건을 만족시키지 않는다.

## Chapter1-3 매개변수의 디폴트 값
* 매개변수에 설정하는 '디폴트 값'의 의미 (= 생략 가능하다는 뜻)
```c++
int MyFuncOne(int num=7)
{
  return num+1;
}
```
  * *인자를* 전달하지 않으면 7이 전달된 것으로 간주한다. 여기서의 디폴트 값은 7이다. 따라서 이 함수를 대상으로 하는 다음 두 함수의 호출은 그 결과가 같다.
    * ```MyFuncOne();``` ```MyFuncOne(7);```

```c++
int MyFuncTwo(it num1 = 5, int num2= 7)
{
  return num1+num2;
}
```
  * *인자를* 전달하지 않으면 각각 5와 7이 전달된 것으로 간주한다.
  따라서 이 함수를 대상으로 하는 다음 두 함수의 호출은 그 결과가 같다.
    * ```MyFuncTwo();```  ```MyFuncTwo(5,7);```
    
* 디폴트 값은 함수

* 부분적 디폴트 값 설정
  * 매개변수의 일부에만 디폴트 값을 지정하고, 채워지지 않은 매개변수에만 인자를 전달하는 것이 가능하다.
    * default ; 생략 가능한 변수를 뒤에서부터 채우고, 맨 앞에 비어 있으면 ok
  * 전달되는 인자가 왼쪽에서부터 채워지므로, 디폴트 값은 오른쪽에서부터 채워져야 한다.
  * 전달되는 인자가 왼쪽에서부터 채워지므로, 오른쪽이 빈 상태로 왼쪽의 매개변수에만 일부 채워진 디폴트 값은 의미를 갖지 못한다. 따라서 컴파일 에러를 일으킨다.

## chapter 1-4 인라인(inline) 함수
* 매크로 함수의 장점과 함수의 inline 선언(굳이 알 필요는 없다.)
  * inline 키워드를 이용해서 매크로처럼 함수의 호출 과정 없이 stack, return과 같은 호출 과정 없이 바로 코드가 그 위치로 가버리는 것
  * 그러면 함수 호출과 스택의 로드와, return값 반환을 위한 스택 작업 등의 번거로운 작업을 생략할 수 있음
  * 하지만 이렇게 한다고 크게 얻는 이득은 없는 것 같다.
  * 그런데 굳이 inline 안써도 된다. 뭐 하고 싶으면 하고. 그 이유는 큰 차이가 없기 때문이다.

* 인라인 함수에는 없는 매크로 함수만의 장점
  * data type에 영향을 받지 않아 독립적이다.

* inline 선언된 함수를 위의 형태로 호출하려면, 각 자료형 별로 함수가 오버로딩되어야 한다.
* 즉, 매크로 함수와 달리 자료형에 독립적이지 못하다.
* 장점 : 함수가 인라인화되어 성능의 향상으로 이어질 수 있다.
* 단점 : 함스의 정의 방식이 일반 함수에 비해서 복잡하다. 따라서 복잡한 함수의 정의에는 한계가 있다.
* 속도와 자원의 효율적인 관리를 할 수 있지만, inline을 고려할 필요는 없다. 말 그대로 컴파일러 상황에 따라서 해줄 수도 있고 아닐 수도 있기 때문. 차라리 #define으로 매크로 함수를 만들도록 한다.
* inline이 아니더라도 templete을 사용해서 매크로 함수처럼 해줄 수 있다.


## chapter 1-5 namespace에 대한 소개
* 잘 안쓰는 것이 좋다는 썰이 있다.
* 큰 규모의 project 모듈 (= project로 구분할 수 있는 정도의 큰 규모)
* namespace의 기본 원리 : 프로그램 모듈화를 위해서 도입을 한 부분이라고 이해하면 좋다.
  * 일반적인 경우 : 프로젝트 명이라고 생각하면 된다.

* namespace : 전역변수와 함수가 포함된 큰 범위의 Module라고 이해하면 된다.

* namespace 기반의 함수 선언과 정의의 분리
  * :: (class) 사용가능, class와 동일하다.

* 중간에 정리하기

* namespace 중첩(쓸데없이 사용하지 말자)
* std::cout, std::cin, std::endl(\n)
  | 목록 | 설명 |
  |:----:|:----|
  |std::cout| 이름 공간 std에 선언된 cout |
  |std::cin | 이름 공간 std에 선언된 cin |
  |std::endl | 이름 공간 std에 선언된 endl|
  
  ->
  ```c++
  namespace std
  {
    cout . . . .
    in ......
    endl .....
  }
  ```
  
  * C++ -> 계층화, 모듈화
  * <iostream>에 선언되어 있는 cout cin 그리고 endl
  
* using을 이용한 namespace의 명시
  * ```using namespace std;```  : namespace std에 선언된 것은 std라는 namespace의 선언없이 접근하겠다는 선언이다. 
  * 너무 빈번한 using namespace의 선언은 이름의 충돌을 막기 위한 namespace의 선언을 의미 없게 만든다.
  * 따라서 제한적으로 사용할 필요가 있다.
  * 실무에서는 사용하지 말 것을 강력히 권장한다. 다른 네임스페이스에 같은 이름의 함수나 변수가 존재할 수 있으며, 이러한 경우 using문으로 전역 네임스페이스에 포함하면 충돌이 일어날 수 있기 때문이다.
  
* namespace의 별칭 지정과 전역변수의 접근
  * 전역 변수는 namespace 내에서 함수의 내용에 있지 않은 즉, 외부에 선언된 변수다.  
  * ex) 외부에 선언된 변수
